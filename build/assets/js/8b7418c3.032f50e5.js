"use strict";(self.webpackChunkai_textbook_frontend=self.webpackChunkai_textbook_frontend||[]).push([[585],{3295:function(e,n,t){t.r(n),t.d(n,{assets:function(){return a},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return i},metadata:function(){return r},toc:function(){return d}});var r=JSON.parse('{"id":"introduction/week-3-control-systems","title":"Week 3: Control Systems Basics","description":"Introduction to Robot Control","source":"@site/docs/01-introduction/week-3-control-systems.mdx","sourceDirName":"01-introduction","slug":"/introduction/week-3-control-systems","permalink":"/ai-textbook/docs/introduction/week-3-control-systems","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/ai-textbook/tree/main/docs/01-introduction/week-3-control-systems.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Week 2: Robot Anatomy & Sensors","permalink":"/ai-textbook/docs/introduction/week-2-robot-anatomy"},"next":{"title":"Week 4: Computer Vision Fundamentals","permalink":"/ai-textbook/docs/perception/week-4-computer-vision"}}'),o=t(4848),s=t(8453);const i={sidebar_position:3},l="Week 3: Control Systems Basics",a={},d=[{value:"Introduction to Robot Control",id:"introduction-to-robot-control",level:2},{value:"The Fundamental Challenge",id:"the-fundamental-challenge",level:3},{value:"Part 1: Closed-Loop Control Fundamentals",id:"part-1-closed-loop-control-fundamentals",level:2},{value:"The PID Controller",id:"the-pid-controller",level:3},{value:"How PID Works",id:"how-pid-works",level:3},{value:"Complete PID Formula",id:"complete-pid-formula",level:3},{value:"PID Control Example",id:"pid-control-example",level:3},{value:"Tuning PID Gains",id:"tuning-pid-gains",level:3},{value:"Part 2: Multi-Joint Coordination",id:"part-2-multi-joint-coordination",level:2},{value:"Independent Joint Control",id:"independent-joint-control",level:3},{value:"Cartesian Control (Inverse Kinematics)",id:"cartesian-control-inverse-kinematics",level:3},{value:"Part 3: Practical Control Architectures",id:"part-3-practical-control-architectures",level:2},{value:"Trajectory Tracking Control",id:"trajectory-tracking-control",level:3},{value:"Impedance Control (Compliant Robots)",id:"impedance-control-compliant-robots",level:3},{value:"Part 4: Stability &amp; Performance Metrics",id:"part-4-stability--performance-metrics",level:2},{value:"Stability",id:"stability",level:3},{value:"Performance Metrics",id:"performance-metrics",level:3},{value:"Real-World Example: Walking Robot Control",id:"real-world-example-walking-robot-control",level:2},{value:"Week 3 Learning Outcomes",id:"week-3-learning-outcomes",level:2},{value:"Key Terminology",id:"key-terminology",level:2},{value:"Discussion Questions",id:"discussion-questions",level:2},{value:"Hands-On Activity",id:"hands-on-activity",level:2},{value:"Resources for Deeper Learning",id:"resources-for-deeper-learning",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"week-3-control-systems-basics",children:"Week 3: Control Systems Basics"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-robot-control",children:"Introduction to Robot Control"}),"\n",(0,o.jsxs)(n.p,{children:["You now understand robot anatomy and sensors. This week, we explore the ",(0,o.jsx)(n.strong,{children:"control systems"})," that coordinate all these components into purposeful action. Control theory is the bridge between sensing and acting."]}),"\n",(0,o.jsx)(n.h3,{id:"the-fundamental-challenge",children:"The Fundamental Challenge"}),"\n",(0,o.jsx)(n.p,{children:"Imagine you command a robot arm to move to a target position. What actually happens?"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:'You specify: "Move to position [0.5m, 0.3m, 0.8m]"'}),"\n",(0,o.jsx)(n.li,{children:'The controller computes: "Joint 1 should rotate 45\xb0, Joint 2 should extend 0.2m, etc."'}),"\n",(0,o.jsx)(n.li,{children:"The motors receive power and start rotating"}),"\n",(0,o.jsx)(n.li,{children:"But motors don't stop exactly where they should\u2014they overshoot or undershoot"}),"\n",(0,o.jsx)(n.li,{children:"Sensors report actual position, which differs from target"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"This is where control systems come in:"})," They continuously adjust motor commands based on sensory feedback to reach and maintain desired positions."]}),"\n",(0,o.jsx)(n.h2,{id:"part-1-closed-loop-control-fundamentals",children:"Part 1: Closed-Loop Control Fundamentals"}),"\n",(0,o.jsx)(n.h3,{id:"the-pid-controller",children:"The PID Controller"}),"\n",(0,o.jsxs)(n.p,{children:["The most common control algorithm in robotics is the ",(0,o.jsx)(n.strong,{children:"PID controller"})," (Proportional-Integral-Derivative)."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Desired State \u2192 [PID Controller] \u2192 Motor Command \u2192 [Robot Actuator] \u2192 Actual State\n                      \u2191                                                    \u2193\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Sensor Feedback \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,o.jsx)(n.h3,{id:"how-pid-works",children:"How PID Works"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Proportional (P) Term:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Error = Desired Position - Actual Position\nCommand = Kp \xd7 Error\n"})}),"\n",(0,o.jsx)(n.p,{children:"If the robot is 10cm away from target:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:'Proportional term says: "Push harder the farther away you are"'}),"\n",(0,o.jsx)(n.li,{children:"Problem: Steady-state error (robot stops slightly before reaching target)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Integral (I) Term:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"IntegratedError = sum of all past errors over time\nCommand += Ki \xd7 IntegratedError\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Accumulates error over time"}),"\n",(0,o.jsx)(n.li,{children:"Eliminates steady-state error"}),"\n",(0,o.jsx)(n.li,{children:"Problem: Can cause oscillations if Kp is too high"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Derivative (D) Term:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"ErrorRate = (Current Error - Previous Error) / dt\nCommand += Kd \xd7 ErrorRate\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Predicts future error based on rate of change"}),"\n",(0,o.jsx)(n.li,{children:"Dampens oscillations (like adding friction)"}),"\n",(0,o.jsx)(n.li,{children:"Makes system respond smoothly"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"complete-pid-formula",children:"Complete PID Formula"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Command = Kp \xd7 Error + Ki \xd7 \u222bError + Kd \xd7 (dError/dt)\n"})}),"\n",(0,o.jsx)(n.h3,{id:"pid-control-example",children:"PID Control Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class PIDController:\n    def __init__(self, kp, ki, kd):\n        """Initialize PID gains"""\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n\n        self.integral = 0\n        self.prev_error = 0\n        self.dt = 0.01  # Control loop runs at 100 Hz\n\n    def compute(self, desired, actual):\n        """Compute motor command based on error"""\n\n        # Calculate error\n        error = desired - actual\n\n        # Proportional term\n        p_term = self.kp * error\n\n        # Integral term (with anti-windup)\n        self.integral += error * self.dt\n        if abs(self.integral) > 10:  # Limit integral wind-up\n            self.integral = 10 if self.integral > 0 else -10\n        i_term = self.ki * self.integral\n\n        # Derivative term\n        d_term = self.kd * (error - self.prev_error) / self.dt\n        self.prev_error = error\n\n        # Compute command\n        command = p_term + i_term + d_term\n\n        # Saturate command to motor limits\n        command = max(-1.0, min(1.0, command))\n\n        return command\n'})}),"\n",(0,o.jsx)(n.h3,{id:"tuning-pid-gains",children:"Tuning PID Gains"}),"\n",(0,o.jsxs)(n.p,{children:["Tuning Kp, Ki, Kd is both art and science. ",(0,o.jsx)(n.strong,{children:"Ziegler-Nichols method"})," is a systematic approach:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"1. Set Ki=0, Kd=0\n2. Increase Kp until system oscillates continuously\n3. Note the oscillation period (Pu) and critical gain (Kcu)\n4. Apply formula:\n   Kp = 0.6 \xd7 Kcu\n   Ki = 1.2 \xd7 Kcu / Pu\n   Kd = 0.075 \xd7 Kcu \xd7 Pu\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Visual Tuning Guide:"})}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Issue"}),(0,o.jsx)(n.th,{children:"Solution"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"System undershoots (too slow)"}),(0,o.jsx)(n.td,{children:"Increase Kp"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"System oscillates (overshoot)"}),(0,o.jsx)(n.td,{children:"Decrease Kp or increase Kd"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Steady-state error exists"}),(0,o.jsx)(n.td,{children:"Increase Ki"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Response too slow"}),(0,o.jsx)(n.td,{children:"Increase Kd"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"System unstable/jerky"}),(0,o.jsx)(n.td,{children:"Decrease all gains"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"part-2-multi-joint-coordination",children:"Part 2: Multi-Joint Coordination"}),"\n",(0,o.jsx)(n.p,{children:"Real robots have multiple joints. Each joint needs its own PID controller, but they must coordinate."}),"\n",(0,o.jsx)(n.h3,{id:"independent-joint-control",children:"Independent Joint Control"}),"\n",(0,o.jsx)(n.p,{children:"The simplest approach: one PID per joint, no coordination."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class RobotArm:\n    def __init__(self):\n        self.joint_controllers = [\n            PIDController(kp=10, ki=2, kd=1),\n            PIDController(kp=8, ki=1.5, kd=0.8),\n            PIDController(kp=7, ki=1, kd=0.5),\n        ]\n        self.joint_angles = [0, 0, 0]\n\n    def move_to_angles(self, target_angles):\n        """Move all joints to target angles"""\n\n        # Control loop\n        for _ in range(1000):  # Run for 10 seconds at 100 Hz\n\n            # For each joint, compute and apply PID command\n            joint_commands = []\n            for i, controller in enumerate(self.joint_controllers):\n                command = controller.compute(\n                    target_angles[i],\n                    self.joint_angles[i]\n                )\n                joint_commands.append(command)\n                self.motors[i].set_command(command)\n\n            # Read back actual angles from encoders\n            self.joint_angles = self.read_joint_angles()\n\n            time.sleep(0.01)  # 100 Hz control rate\n'})}),"\n",(0,o.jsx)(n.h3,{id:"cartesian-control-inverse-kinematics",children:"Cartesian Control (Inverse Kinematics)"}),"\n",(0,o.jsxs)(n.p,{children:["Sometimes you want to control the robot's ",(0,o.jsx)(n.strong,{children:"end effector"})," in Cartesian space (x, y, z) rather than joint angles."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Goal: Move end effector to [0.5m, 0.3m, 0.8m]\n\u2193 Inverse Kinematics\nTarget Joint Angles: [45\xb0, 60\xb0, 30\xb0]\n\u2193 Joint PID Controllers\nJoint Commands sent to motors\n"})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Inverse Kinematics Challenge:"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class InverseKinematics:\n    def solve_ik(self, target_position):\n        """\n        Find joint angles that result in target end effector position\n        This is computationally expensive!\n        """\n\n        # For 3-joint arm: multiple solutions can exist\n        # You need to choose one (e.g., minimum joint motion)\n\n        # Method 1: Analytical solution (if math is tractable)\n        # For specific robot geometry, may have closed-form equations\n        joint_angles = self.analytical_solution(target_position)\n\n        # Method 2: Numerical optimization (if no closed form exists)\n        # Use gradient descent to find angles that match target\n        joint_angles = self.numerical_optimize(target_position)\n\n        return joint_angles\n\n    def analytical_solution(self, target_pos):\n        """Closed-form solution for 3-joint planar arm"""\n        x, y = target_pos[0], target_pos[1]\n\n        # Using law of cosines and trigonometry\n        # (specific to this robot\'s geometry)\n        theta3 = acos((x**2 + y**2 - L1**2 - L2**2) / (2*L1*L2))\n        theta2 = atan2(y, x) - atan2(L2*sin(theta3), L1+L2*cos(theta3))\n        theta1 = 0  # Simplified\n\n        return [theta1, theta2, theta3]\n'})}),"\n",(0,o.jsx)(n.h2,{id:"part-3-practical-control-architectures",children:"Part 3: Practical Control Architectures"}),"\n",(0,o.jsx)(n.h3,{id:"trajectory-tracking-control",children:"Trajectory Tracking Control"}),"\n",(0,o.jsx)(n.p,{children:"Moving smoothly from point A to point B while avoiding jerky motions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class TrajectoryController:\n    def move_smoothly(self, start_pos, end_pos, duration=2.0):\n        """\n        Generate smooth trajectory and track it\n        Uses 5th-order polynomial for smooth acceleration/deceleration\n        """\n\n        # Generate trajectory: position, velocity, acceleration over time\n        timestamps = []\n        positions = []\n        velocities = []\n\n        for t in range(int(duration * 100)):  # 100 Hz\n            tau = t / (duration * 100)  # Normalized time [0, 1]\n\n            # 5th order polynomial: smooth acceleration\n            s = 10*tau**3 - 15*tau**4 + 6*tau**5\n            s_dot = (30*tau**2 - 60*tau**3 + 30*tau**4) / duration\n            s_ddot = (60*tau - 180*tau**2 + 120*tau**3) / (duration**2)\n\n            pos = start_pos + s * (end_pos - start_pos)\n            vel = s_dot * (end_pos - start_pos)\n\n            timestamps.append(t * 0.01)\n            positions.append(pos)\n            velocities.append(vel)\n\n        # Now track this trajectory with feedback control\n        for i, (pos_target, vel_target) in enumerate(zip(positions, velocities)):\n\n            # Feedforward: use desired velocity to improve tracking\n            # Feedback: use PID to correct for errors\n\n            error = pos_target - self.get_actual_position()\n            feedforward = vel_target\n            feedback = self.pid_controller.compute(error)\n\n            command = feedforward + feedback\n\n            self.set_motor_command(command)\n            time.sleep(0.01)\n'})}),"\n",(0,o.jsx)(n.h3,{id:"impedance-control-compliant-robots",children:"Impedance Control (Compliant Robots)"}),"\n",(0,o.jsxs)(n.p,{children:["When robots must work near humans or handle delicate objects, they need ",(0,o.jsx)(n.strong,{children:"compliant control"}),"\u2014they should give way when touched, like a spring."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class ImpedanceController:\n    def __init__(self):\n        self.stiffness = 1000      # Spring constant (N/m)\n        self.damping = 100         # Friction coefficient (N\u22c5s/m)\n        self.target_pos = 0\n\n    def compute_command(self, actual_pos, actual_vel, external_force):\n        """\n        Like a spring-damper system:\n        Force = -Stiffness \xd7 Error - Damping \xd7 Velocity\n        """\n\n        # Calculate desired force based on position error\n        error = self.target_pos - actual_pos\n        spring_force = self.stiffness * error\n\n        # Add damping to smooth motion\n        damping_force = -self.damping * actual_vel\n\n        # Account for external forces (contact with human)\n        total_force = spring_force + damping_force + external_force\n\n        # Convert force to motor command\n        command = total_force / self.motor_constant\n\n        return command\n'})}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Benefits of Impedance Control:"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"If human pushes on robot, it moves away (safety)"}),"\n",(0,o.jsx)(n.li,{children:"If robot pushes against wall, it stops (contact awareness)"}),"\n",(0,o.jsx)(n.li,{children:"Energy efficient (robot absorbs disturbances rather than fighting them)"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"part-4-stability--performance-metrics",children:"Part 4: Stability & Performance Metrics"}),"\n",(0,o.jsx)(n.h3,{id:"stability",children:"Stability"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"stable"})," system converges to desired state and doesn't oscillate forever."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"Unstable:              Marginally Stable:      Stable (Underdamped):\n   \u2502                        \u2502                          \u2502\n   \u2502      \u2571                  \u2502  \u2500\u2500\u2500\u2500\u2500\u2500                  \u2502    \u2571\u203e\u203e\u203e\n   \u2502    \u2571                    \u2502                         \u2502  \u2571\u2571\n   \u2502  \u2571                      \u2502                         \u2502\u2571\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Nyquist Criterion"})," and ",(0,o.jsx)(n.strong,{children:"Bode Plots"})," are mathematical tools for analyzing stability, but practically:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"If gains are too high \u2192 oscillations (instability)"}),"\n",(0,o.jsx)(n.li,{children:"If gains are too low \u2192 slow response, won't reach target"}),"\n",(0,o.jsx)(n.li,{children:"Balanced tuning \u2192 stable, fast response"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"performance-metrics",children:"Performance Metrics"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Metric"}),(0,o.jsx)(n.th,{children:"Definition"}),(0,o.jsx)(n.th,{children:"Ideal Value"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Rise Time (tr)"})}),(0,o.jsx)(n.td,{children:"Time to reach 90% of target"}),(0,o.jsx)(n.td,{children:"Fast (0.1-1s)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Overshoot (OS)"})}),(0,o.jsx)(n.td,{children:"Max excess beyond target"}),(0,o.jsx)(n.td,{children:"<5%"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Settling Time (ts)"})}),(0,o.jsx)(n.td,{children:"Time to stay within 2% of target"}),(0,o.jsx)(n.td,{children:"Fast (< 10 \xd7 tr)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Steady-State Error (ess)"})}),(0,o.jsx)(n.td,{children:"Final error after settling"}),(0,o.jsx)(n.td,{children:"0"})]})]})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class PerformanceAnalyzer:\n    def analyze_response(self, time_series, target_value):\n        """Measure control performance metrics"""\n\n        steady_state_value = time_series[-1]\n        peak_value = max(time_series)\n        overshoot = ((peak_value - target_value) / target_value) * 100\n\n        # Rise time: when does signal reach 90% of target?\n        rise_indices = [i for i, v in enumerate(time_series)\n                       if v >= 0.9 * target_value]\n        rise_time = rise_indices[0] * dt if rise_indices else float(\'inf\')\n\n        # Settling time: when does signal stay within 2% of target?\n        settled_indices = [i for i, v in enumerate(time_series[int(rise_time/dt):])\n                          if abs(v - target_value) < 0.02 * target_value]\n        settling_time = (int(rise_time/dt) + settled_indices[0]) * dt\n\n        steady_state_error = abs(steady_state_value - target_value)\n\n        return {\n            "rise_time": rise_time,\n            "overshoot": overshoot,\n            "settling_time": settling_time,\n            "steady_state_error": steady_state_error\n        }\n'})}),"\n",(0,o.jsx)(n.h2,{id:"real-world-example-walking-robot-control",children:"Real-World Example: Walking Robot Control"}),"\n",(0,o.jsx)(n.p,{children:"Let's see control systems in action for a quadruped robot walking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class QuadrupedGaitController:\n    def __init__(self):\n        # Each leg has 3 joints: hip, knee, ankle\n        # Each joint has a PID controller\n        self.leg_controllers = [\n            [PIDController(10, 2, 1) for _ in range(3)]\n            for _ in range(4)  # 4 legs\n        ]\n\n    def walk_forward(self, speed=0.5):  # 0.5 m/s\n        """Generate walking gait and control legs"""\n\n        phase = 0\n        while True:\n            # Compute desired joint angles for each leg\n            # based on gait phase (0 to 1)\n\n            for leg_id in range(4):\n                # Quadruped trot gait:\n                # - Front-left and back-right legs move together\n                # - Then front-right and back-left legs move together\n\n                if leg_id in [0, 3]:  # Front-left, back-right\n                    leg_phase = phase\n                else:  # Front-right, back-left\n                    leg_phase = (phase + 0.5) % 1.0\n\n                # Compute desired angles using gait function\n                target_angles = self.compute_gait_angles(leg_phase)\n\n                # Control each joint to reach target\n                for joint_id, target_angle in enumerate(target_angles):\n                    actual_angle = self.get_joint_angle(leg_id, joint_id)\n                    command = self.leg_controllers[leg_id][joint_id].compute(\n                        target_angle, actual_angle\n                    )\n                    self.set_motor_command(leg_id, joint_id, command)\n\n            # Advance phase\n            phase = (phase + 0.01) % 1.0\n            time.sleep(0.01)\n\n    def compute_gait_angles(self, phase):\n        """\n        Compute desired joint angles for current gait phase\n        phase: 0 to 1 (0 = stance start, 1 = stance end)\n        """\n\n        if phase < 0.6:  # Stance phase (60% of cycle)\n            # Leg pushes backward\n            hip_angle = -30 + 30 * phase    # From -30\xb0 to 0\xb0\n            knee_angle = -45                # Mostly fixed\n            ankle_angle = 0                 # Mostly fixed\n\n        else:  # Swing phase (40% of cycle)\n            # Leg swings forward\n            swing_progress = (phase - 0.6) / 0.4\n            hip_angle = 30 * sin(swing_progress * \u03c0)\n            knee_angle = -90 + 60 * sin(swing_progress * \u03c0)\n            ankle_angle = 0\n\n        return [hip_angle, knee_angle, ankle_angle]\n'})}),"\n",(0,o.jsx)(n.h2,{id:"week-3-learning-outcomes",children:"Week 3 Learning Outcomes"}),"\n",(0,o.jsx)(n.p,{children:"By the end of this week, you should be able to:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Explain"})," how closed-loop control uses feedback to correct errors"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Design"})," and tune a PID controller for a robotic joint"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Compare"})," proportional, integral, and derivative terms and their effects"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Implement"})," multi-joint coordination for a robot arm"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Analyze"})," control system performance using metrics like rise time and overshoot"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Apply"})," impedance control for compliant robot behavior"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"key-terminology",children:"Key Terminology"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Term"}),(0,o.jsx)(n.th,{children:"Definition"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Closed-loop Control"})}),(0,o.jsx)(n.td,{children:"System adjusts actions based on feedback to reach goal"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"PID Controller"})}),(0,o.jsx)(n.td,{children:"Proportional-Integral-Derivative controller for error correction"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Setpoint"})}),(0,o.jsx)(n.td,{children:"Desired state the control system tries to achieve"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Error Signal"})}),(0,o.jsx)(n.td,{children:"Difference between desired and actual state"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Transient Response"})}),(0,o.jsx)(n.td,{children:"How quickly system reaches desired state"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Steady-State Error"})}),(0,o.jsx)(n.td,{children:"Final error after system settles"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Impedance"})}),(0,o.jsx)(n.td,{children:"System's resistance to external forces (spring-like)"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.strong,{children:"Overshoot"})}),(0,o.jsx)(n.td,{children:"Exceeding target value before settling"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"discussion-questions",children:"Discussion Questions"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Tuning Tradeoffs"}),": Why is fast control (high Kp) sometimes bad? What problems does it cause?"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Multi-Joint Coordination"}),": A robot arm must reach a target position quickly but smoothly. Should you control the joints independently or use inverse kinematics? What are the tradeoffs?"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Human-Robot Interaction"}),": Why would a surgical robot need different impedance control than an industrial assembly robot?"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Performance vs Safety"}),": A PID controller can be tuned for fast response OR for stability. Why is this a tradeoff? Can both be achieved?"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"hands-on-activity",children:"Hands-On Activity"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Simulate PID Control"})}),"\n",(0,o.jsx)(n.p,{children:"Using a physics simulation or online tool:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsx)(n.li,{children:"Set up a mass on a spring"}),"\n",(0,o.jsx)(n.li,{children:"Implement PID controller to move mass to target position"}),"\n",(0,o.jsxs)(n.li,{children:["Try different Kp, Ki, Kd values and observe:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"How fast does it reach target?"}),"\n",(0,o.jsx)(n.li,{children:"Does it overshoot?"}),"\n",(0,o.jsx)(n.li,{children:"Does it oscillate?"}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.li,{children:"Document your best tuning and explain why it works"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Tools:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Online: ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/PID_controller",children:"Control Systems Simulator"})]}),"\n",(0,o.jsxs)(n.li,{children:["Python: ",(0,o.jsx)(n.code,{children:"control"})," library"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"resources-for-deeper-learning",children:"Resources for Deeper Learning"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Book"}),': "Modern Control Systems" - Richard Dorf & Robert Bishop']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Video"}),': "PID Control Explained" - Brian Douglas (Control System Lectures)']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Tool"}),": MATLAB/Simulink for control system design and simulation"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Paper"}),': "The Ziegler\u2013Nichols Tuning Method" - classic reference']}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Interactive"}),": Interactive PID tuning simulator with visualizations"]}),"\n"]}),"\n",(0,o.jsx)(n.hr,{}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Next"}),": Module 1 Capstone - Building a Complete Embodied AI System"]}),"\n",(0,o.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,o.jsx)(n.strong,{children:"Tip"}),': Real robots almost never use "pure" PID. They combine feedforward (expected commands), feedback (error correction), and sometimes learning (neural networks) for optimal control!']})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:function(e,n,t){t.d(n,{R:function(){return i},x:function(){return l}});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);