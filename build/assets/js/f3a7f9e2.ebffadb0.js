"use strict";(self.webpackChunkai_textbook_frontend=self.webpackChunkai_textbook_frontend||[]).push([[104],{476:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return a},metadata:function(){return o},toc:function(){return c}});var o=JSON.parse('{"id":"control/week-8-trajectory-planning","title":"Week 8: Trajectory Planning & Collision Avoidance","description":"Beyond Path to Trajectory","source":"@site/docs/03-control/week-8-trajectory-planning.mdx","sourceDirName":"03-control","slug":"/control/week-8-trajectory-planning","permalink":"/ai-textbook/docs/control/week-8-trajectory-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/ai-textbook/tree/main/docs/03-control/week-8-trajectory-planning.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Week 7: Path Planning","permalink":"/ai-textbook/docs/control/week-7-path-planning"},"next":{"title":"Week 9: Mobile Robot Navigation","permalink":"/ai-textbook/docs/control/week-9-mobile-navigation"}}'),i=t(4848),r=t(8453);const a={sidebar_position:2},s="Week 8: Trajectory Planning & Collision Avoidance",l={},c=[{value:"Beyond Path to Trajectory",id:"beyond-path-to-trajectory",level:2},{value:"Part 1: Trajectory Generation",id:"part-1-trajectory-generation",level:2},{value:"Time-Optimal Trajectories",id:"time-optimal-trajectories",level:3},{value:"Part 2: Dynamic Window Approach (DWA)",id:"part-2-dynamic-window-approach-dwa",level:2},{value:"Part 3: MPC (Model Predictive Control)",id:"part-3-mpc-model-predictive-control",level:2},{value:"Real-World: Mobile Robot Navigation",id:"real-world-mobile-robot-navigation",level:2},{value:"Week 8 Learning Outcomes",id:"week-8-learning-outcomes",level:2},{value:"Key Terminology",id:"key-terminology",level:2},{value:"Discussion Questions",id:"discussion-questions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"week-8-trajectory-planning--collision-avoidance",children:"Week 8: Trajectory Planning & Collision Avoidance"})}),"\n",(0,i.jsx)(n.h2,{id:"beyond-path-to-trajectory",children:"Beyond Path to Trajectory"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"path"})," is a sequence of poses. A ",(0,i.jsx)(n.strong,{children:"trajectory"})," adds timing: when the robot should be at each pose."]}),"\n",(0,i.jsx)(n.p,{children:"This matters because:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Physical robots can't instantly change direction"}),"\n",(0,i.jsx)(n.li,{children:"Actuators have acceleration limits"}),"\n",(0,i.jsx)(n.li,{children:"Collision avoidance requires speed management"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"part-1-trajectory-generation",children:"Part 1: Trajectory Generation"}),"\n",(0,i.jsx)(n.h3,{id:"time-optimal-trajectories",children:"Time-Optimal Trajectories"}),"\n",(0,i.jsx)(n.p,{children:"Maximize speed while respecting acceleration limits."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class TrajectoryPlanner:\n    def __init__(self, max_velocity=1.0, max_acceleration=0.5):\n        """Initialize trajectory planner"""\n        self.max_velocity = max_velocity\n        self.max_acceleration = max_acceleration\n\n    def generate_trajectory(self, waypoints):\n        """Generate time-optimal trajectory through waypoints"""\n\n        trajectory = []\n\n        for i in range(len(waypoints)-1):\n            start = waypoints[i]\n            end = waypoints[i+1]\n\n            distance = np.linalg.norm(np.array(end) - np.array(start))\n\n            # Compute time to traverse segment\n            # Phase 1: Accelerate to max velocity\n            time_to_max_v = self.max_velocity / self.max_acceleration\n            distance_accel = 0.5 * self.max_acceleration * time_to_max_v**2\n\n            if distance <= 2 * distance_accel:\n                # Can\'t reach max velocity\n                t_max = 2 * np.sqrt(distance / self.max_acceleration)\n                v_max = self.max_acceleration * t_max / 2\n            else:\n                # Can reach max velocity\n                distance_cruise = distance - 2 * distance_accel\n                time_cruise = distance_cruise / self.max_velocity\n                t_max = 2 * time_to_max_v + time_cruise\n                v_max = self.max_velocity\n\n            # Generate waypoints along trajectory\n            dt = 0.01  # 100 Hz\n            for t in np.arange(0, t_max, dt):\n                if t <= time_to_max_v:\n                    # Acceleration phase\n                    v = self.max_acceleration * t\n                    s = 0.5 * self.max_acceleration * t**2\n\n                elif t <= t_max - time_to_max_v:\n                    # Cruise phase\n                    s = distance_accel + v_max * (t - time_to_max_v)\n                    v = v_max\n\n                else:\n                    # Deceleration phase\n                    t_decel = t_max - t\n                    v = self.max_acceleration * t_decel\n                    s = distance - 0.5 * self.max_acceleration * t_decel**2\n\n                # Interpolate position\n                direction = (np.array(end) - np.array(start)) / distance\n                pose = np.array(start) + direction * s\n\n                trajectory.append({\n                    \'pose\': pose,\n                    \'velocity\': v,\n                    \'time\': t\n                })\n\n        return trajectory\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-2-dynamic-window-approach-dwa",children:"Part 2: Dynamic Window Approach (DWA)"}),"\n",(0,i.jsx)(n.p,{children:"For reactive collision avoidance at high frequencies (e.g., 20 Hz)."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class DynamicWindowApproach:\n    def __init__(self, max_velocity=1.0, max_rotation=np.pi, max_accel=0.5):\n        self.max_velocity = max_velocity\n        self.max_rotation = max_rotation\n        self.max_accel = max_accel\n        self.last_velocities = (0, 0)  # (linear, angular)\n\n    def compute_velocity_command(self, robot_pose, goal, obstacles, dt=0.1):\n        """Compute optimal velocity command"""\n\n        # 1. Dynamic Window: velocities robot can reach in next dt\n        min_v = max(self.last_velocities[0] - self.max_accel * dt, -self.max_velocity)\n        max_v = min(self.last_velocities[0] + self.max_accel * dt, self.max_velocity)\n\n        min_w = max(self.last_velocities[1] - self.max_accel * dt, -self.max_rotation)\n        max_w = min(self.last_velocities[1] + self.max_accel * dt, self.max_rotation)\n\n        # 2. Sample velocity combinations\n        best_score = -float(\'inf\')\n        best_velocity = (0, 0)\n\n        for v in np.linspace(min_v, max_v, 5):\n            for w in np.linspace(min_w, max_w, 5):\n\n                # 3. Evaluate trajectory\n                collision_risk = self.collision_risk(robot_pose, v, w, obstacles)\n\n                if collision_risk > 0.5:  # Too risky\n                    continue\n\n                # Distance to goal\n                goal_dist = self.trajectory_distance_to_goal(\n                    robot_pose, v, w, goal, dt\n                )\n\n                # Score: minimize distance, avoid obstacles\n                score = (1.0 - collision_risk) - goal_dist / 10\n\n                if score > best_score:\n                    best_score = score\n                    best_velocity = (v, w)\n\n        self.last_velocities = best_velocity\n        return best_velocity\n\n    def collision_risk(self, pose, v, w, obstacles, time_horizon=1.0):\n        """Compute collision risk for velocity command"""\n\n        x, y, theta = pose\n        min_distance = float(\'inf\')\n\n        # Simulate trajectory\n        for t in np.linspace(0, time_horizon, 10):\n            # Kinematic model\n            x_t = x + v * np.cos(theta) * t\n            y_t = y + v * np.sin(theta) * t\n\n            # Check distance to obstacles\n            for obs in obstacles:\n                obs_x, obs_y, obs_r = obs\n                distance = np.sqrt((x_t - obs_x)**2 + (y_t - obs_y)**2)\n                min_distance = min(min_distance, distance - obs_r)\n\n        # Convert to risk [0, 1]\n        risk = max(0, 1 - min_distance / 0.5)  # 0.5m safety margin\n        return risk\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-3-mpc-model-predictive-control",children:"Part 3: MPC (Model Predictive Control)"}),"\n",(0,i.jsx)(n.p,{children:"Plan ahead while respecting constraints."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ModelPredictiveController:\n    def __init__(self, prediction_horizon=10, control_horizon=3):\n        self.prediction_horizon = prediction_horizon\n        self.control_horizon = control_horizon\n\n    def compute_control(self, current_state, reference_trajectory, constraints):\n        """\n        Solve optimal control problem:\n        minimize: trajectory_tracking_error + control_effort\n        subject to: dynamics, velocity limits, collision avoidance\n        """\n\n        # This is simplified; real MPC uses optimization solvers (CVXPY, Gurobi)\n\n        optimal_control = []\n\n        for i in range(self.control_horizon):\n            # Predict next states\n            predicted_states = self.predict_states(\n                current_state, i, reference_trajectory\n            )\n\n            # Find control minimizing cost\n            for u_candidate in self.candidate_controls():\n\n                cost = self.compute_cost(predicted_states, u_candidate)\n\n                if self.satisfies_constraints(predicted_states, constraints):\n                    optimal_control.append(u_candidate)\n                    break\n\n        return optimal_control[0] if optimal_control else (0, 0)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"real-world-mobile-robot-navigation",children:"Real-World: Mobile Robot Navigation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class MobileRobotNavigator:\n    def __init__(self):\n        self.path_planner = AStarPlanner()\n        self.trajectory_planner = TrajectoryPlanner()\n        self.collision_avoider = DynamicWindowApproach()\n\n    def navigate_to_goal(self, robot_pose, goal, map_grid, dynamic_obstacles):\n        """Complete navigation pipeline"""\n\n        # 1. PLAN: Path planning (static obstacles)\n        path = self.path_planner.plan(robot_pose[:2], goal, map_grid)\n\n        if not path:\n            return None\n\n        # 2. TRAJECTORY: Generate smooth trajectory\n        trajectory = self.trajectory_planner.generate_trajectory(path)\n\n        # 3. EXECUTE: Follow trajectory with collision avoidance\n        control_commands = []\n\n        for waypoint in trajectory:\n            # Get velocity command that follows trajectory\n            # but avoids dynamic obstacles\n            v_cmd = self.collision_avoider.compute_velocity_command(\n                robot_pose, waypoint[\'pose\'], dynamic_obstacles\n            )\n\n            control_commands.append(v_cmd)\n\n        return control_commands\n'})}),"\n",(0,i.jsx)(n.h2,{id:"week-8-learning-outcomes",children:"Week 8 Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this week, you should be able to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design"})," time-optimal trajectories respecting limits"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement"})," reactive collision avoidance (DWA)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Apply"})," Model Predictive Control for constrained motion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Combine"})," path planning + trajectory planning + collision avoidance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Analyze"})," tradeoffs between optimality and real-time performance"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Test"})," navigation in dynamic environments"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"key-terminology",children:"Key Terminology"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Term"}),(0,i.jsx)(n.th,{children:"Definition"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Trajectory"})}),(0,i.jsx)(n.td,{children:"Path with timing information"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Dynamic Window"})}),(0,i.jsx)(n.td,{children:"Set of velocities robot can reach"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Collision risk"})}),(0,i.jsx)(n.td,{children:"Probability of collision given trajectory"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"MPC"})}),(0,i.jsx)(n.td,{children:"Model Predictive Control - look-ahead optimization"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Kinematic model"})}),(0,i.jsx)(n.td,{children:"How velocity commands translate to pose changes"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Smoothing"})}),(0,i.jsx)(n.td,{children:"Removing sharp turns from paths"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.strong,{children:"Reactive control"})}),(0,i.jsx)(n.td,{children:"High-frequency feedback response to obstacles"})]})]})]}),"\n",(0,i.jsx)(n.h2,{id:"discussion-questions",children:"Discussion Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Real-time vs optimal"}),": Would you use time-optimal planning (slow, optimal) or reactive DWA (fast, suboptimal)?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Prediction"}),": DWA predicts 1 second into future. What happens with faster obstacles?"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Safety margin"}),": How much clearance should robot maintain from obstacles?"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next"}),": Week 9 - Mobile Robot Navigation"]}),"\n",(0,i.jsxs)(n.p,{children:["\ud83d\udca1 ",(0,i.jsx)(n.strong,{children:"Tip"}),": Test your trajectory planner on recorded robot logs. Compare planned vs. actual paths!"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:function(e,n,t){t.d(n,{R:function(){return a},x:function(){return s}});var o=t(6540);const i={},r=o.createContext(i);function a(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);