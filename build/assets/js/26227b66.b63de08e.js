"use strict";(self.webpackChunkai_textbook_frontend=self.webpackChunkai_textbook_frontend||[]).push([[988],{1827:function(e,n,t){t.r(n),t.d(n,{assets:function(){return a},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return o},metadata:function(){return r},toc:function(){return d}});var r=JSON.parse('{"id":"integration/week-11-deployment","title":"Week 11: System Integration & Real-World Deployment","description":"From Simulation to Reality","source":"@site/docs/04-integration/week-11-deployment.mdx","sourceDirName":"04-integration","slug":"/integration/week-11-deployment","permalink":"/ai-textbook/docs/integration/week-11-deployment","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/ai-textbook/tree/main/docs/04-integration/week-11-deployment.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Week 10: Learning from Data & Imitation Learning","permalink":"/ai-textbook/docs/integration/week-10-learning"},"next":{"title":"Week 12: Capstone Project & Future Directions","permalink":"/ai-textbook/docs/integration/week-12-capstone"}}'),i=t(4848),s=t(8453);const o={sidebar_position:2},l="Week 11: System Integration & Real-World Deployment",a={},d=[{value:"From Simulation to Reality",id:"from-simulation-to-reality",level:2},{value:"Part 1: Reality Gap",id:"part-1-reality-gap",level:2},{value:"Sources of Sim-to-Real Gap",id:"sources-of-sim-to-real-gap",level:3},{value:"Domain Randomization",id:"domain-randomization",level:3},{value:"Part 2: Testing Checklist",id:"part-2-testing-checklist",level:2},{value:"Part 3: Handling Failures",id:"part-3-handling-failures",level:2},{value:"Week 11 Learning Outcomes",id:"week-11-learning-outcomes",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"week-11-system-integration--real-world-deployment",children:"Week 11: System Integration & Real-World Deployment"})}),"\n",(0,i.jsx)(n.h2,{id:"from-simulation-to-reality",children:"From Simulation to Reality"}),"\n",(0,i.jsx)(n.p,{children:"All components work perfectly in simulation. Real robots introduce noise, delays, and failures. This week bridges the gap."}),"\n",(0,i.jsx)(n.h2,{id:"part-1-reality-gap",children:"Part 1: Reality Gap"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Sim-to-real transfer"})," is the challenge of deploying algorithms trained/tested in simulation to real robots."]}),"\n",(0,i.jsx)(n.h3,{id:"sources-of-sim-to-real-gap",children:"Sources of Sim-to-Real Gap"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Simulation"}),(0,i.jsx)(n.th,{children:"Reality"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Perfect physics"}),(0,i.jsx)(n.td,{children:"Friction, slipping, wear"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"No noise"}),(0,i.jsx)(n.td,{children:"Sensor noise, quantization"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Zero latency"}),(0,i.jsx)(n.td,{children:"10-200ms control delays"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Infinite compute"}),(0,i.jsx)(n.td,{children:"Limited embedded CPUs"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Known environment"}),(0,i.jsx)(n.td,{children:"Unknown, dynamic environments"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"domain-randomization",children:"Domain Randomization"}),"\n",(0,i.jsx)(n.p,{children:"Randomize simulation parameters so policy learns robust behavior."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class SimulationEnv:\n    def randomize_parameters(self):\n        """Randomize physics for robustness"""\n\n        # Friction coefficient\n        self.friction = np.random.uniform(0.1, 1.5)\n\n        # Mass variations\n        self.mass = np.random.uniform(0.9, 1.1) * self.nominal_mass\n\n        # Motor delays\n        self.motor_delay = np.random.randint(0, 50)  # ms\n\n        # Sensor noise\n        self.sensor_noise = np.random.uniform(0.001, 0.01)\n\n        # Image quality (blur, noise)\n        self.image_blur = np.random.uniform(0, 2)\n        self.image_noise = np.random.uniform(0, 0.05)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-2-testing-checklist",children:"Part 2: Testing Checklist"}),"\n",(0,i.jsx)(n.p,{children:"Before deploying to real robot:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class DeploymentValidator:\n    def validate_all(self):\n        """Complete validation suite"""\n\n        tests = {\n            \'perception\': [\n                self.test_camera_calibration(),\n                self.test_lidar_accuracy(),\n                self.test_imu_drift(),\n            ],\n            \'localization\': [\n                self.test_slam_initialized(),\n                self.test_map_consistency(),\n                self.test_drift_rate(),\n            ],\n            \'planning\': [\n                self.test_planner_convergence(),\n                self.test_collision_detection(),\n                self.test_replanning_latency(),\n            ],\n            \'control\': [\n                self.test_motor_calibration(),\n                self.test_command_latency(),\n                self.test_safety_limits(),\n            ],\n            \'integration\': [\n                self.test_full_stack_10_minutes(),\n                self.test_failure_recovery(),\n                self.test_emergency_stop(),\n            ]\n        }\n\n        all_passed = all(\n            all(test for test in category)\n            for category in tests.values()\n        )\n\n        return all_passed, tests\n\n    def test_emergency_stop(self):\n        """Ensure robot stops immediately"""\n        # Send stop command\n        self.robot.stop()\n\n        # Verify wheels stopped within 500ms\n        time.sleep(0.5)\n        assert self.robot.velocity == 0\n        return True\n'})}),"\n",(0,i.jsx)(n.h2,{id:"part-3-handling-failures",children:"Part 3: Handling Failures"}),"\n",(0,i.jsx)(n.p,{children:"Robots fail. Design for recovery."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class RobotSupervisor:\n    def __init__(self):\n        self.health_checks = {\n            \'lidar\': self.check_lidar,\n            \'imu\': self.check_imu,\n            \'motors\': self.check_motors,\n            \'compute\': self.check_cpu_temp,\n        }\n\n        self.failure_responses = {\n            \'lidar_failure\': self.stop_and_alert,\n            \'imu_failure\': self.use_wheel_odometry_only,\n            \'motor_failure\': self.enable_limp_mode,\n            \'compute_overheat\': self.reduce_frequency,\n        }\n\n    def monitor(self):\n        """Continuous health monitoring"""\n\n        while True:\n            failures = {}\n\n            for name, check in self.health_checks.items():\n                status, error = check()\n                if not status:\n                    failures[name] = error\n\n            # Handle failures\n            for failure_type, error_info in failures.items():\n                self.handle_failure(failure_type, error_info)\n\n            time.sleep(1)\n\n    def check_lidar(self):\n        """Check LIDAR health"""\n        try:\n            scan = self.robot.get_lidar_scan()\n            if len(scan) < 360:  # Should have 360 points\n                return False, "Low scan count"\n            return True, None\n        except:\n            return False, "LIDAR communication failure"\n\n    def handle_failure(self, failure_type, error_info):\n        """Execute failure response"""\n\n        response = self.failure_responses.get(failure_type)\n        if response:\n            response(error_info)\n        else:\n            self.stop_and_alert(error_info)\n\n    def stop_and_alert(self, error_info):\n        """Emergency stop"""\n        self.robot.stop()\n        self.notify_operator(f"Robot stopped: {error_info}")\n\n    def limp_mode(self):\n        """Continue with reduced capability"""\n        # Use wheels only, no arm control\n        print("Limp mode: Motors degraded, reduced autonomy")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"week-11-learning-outcomes",children:"Week 11 Learning Outcomes"}),"\n",(0,i.jsx)(n.p,{children:"By the end of this week, you should be able to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Identify"})," sources of sim-to-real gap"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Apply"})," domain randomization for robust policies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Implement"})," comprehensive validation suite"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Design"})," failure detection and recovery systems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Debug"})," robot behavior on real hardware"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Deploy"})," systems safely and confidently"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Next"}),": Week 12 - Capstone & Future Directions"]})]})}function f(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:function(e,n,t){t.d(n,{R:function(){return o},x:function(){return l}});var r=t(6540);const i={},s=r.createContext(i);function o(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);