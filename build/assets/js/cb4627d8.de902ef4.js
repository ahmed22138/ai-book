"use strict";(self.webpackChunkai_textbook_frontend=self.webpackChunkai_textbook_frontend||[]).push([[999],{518:function(n,e,i){i.r(e),i.d(e,{assets:function(){return l},contentTitle:function(){return a},default:function(){return h},frontMatter:function(){return o},metadata:function(){return r},toc:function(){return c}});var r=JSON.parse('{"id":"control/week-7-path-planning","title":"Week 7: Path Planning","description":"The Navigation Problem","source":"@site/docs/03-control/week-7-path-planning.mdx","sourceDirName":"03-control","slug":"/control/week-7-path-planning","permalink":"/ai-textbook/docs/control/week-7-path-planning","draft":false,"unlisted":false,"editUrl":"https://github.com/your-username/ai-textbook/tree/main/docs/03-control/week-7-path-planning.mdx","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Week 6: SLAM & Localization","permalink":"/ai-textbook/docs/perception/week-6-slam"},"next":{"title":"Week 8: Trajectory Planning & Collision Avoidance","permalink":"/ai-textbook/docs/control/week-8-trajectory-planning"}}'),s=i(4848),t=i(8453);const o={sidebar_position:1},a="Week 7: Path Planning",l={},c=[{value:"The Navigation Problem",id:"the-navigation-problem",level:2},{value:"Part 1: Configuration Space",id:"part-1-configuration-space",level:2},{value:"2D Mobile Robot C-Space",id:"2d-mobile-robot-c-space",level:3},{value:"Part 2: Graph-Based Planning",id:"part-2-graph-based-planning",level:2},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:3},{value:"A* Algorithm",id:"a-algorithm",level:3},{value:"Part 3: Sampling-Based Planning",id:"part-3-sampling-based-planning",level:2},{value:"Rapidly-exploring Random Tree (RRT)",id:"rapidly-exploring-random-tree-rrt",level:3},{value:"Part 4: Real-World Planning",id:"part-4-real-world-planning",level:2},{value:"Handling Dynamic Obstacles",id:"handling-dynamic-obstacles",level:3},{value:"Week 7 Learning Outcomes",id:"week-7-learning-outcomes",level:2},{value:"Key Terminology",id:"key-terminology",level:2},{value:"Discussion Questions",id:"discussion-questions",level:2},{value:"Hands-On Activity",id:"hands-on-activity",level:2},{value:"Resources for Deeper Learning",id:"resources-for-deeper-learning",level:2}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"week-7-path-planning",children:"Week 7: Path Planning"})}),"\n",(0,s.jsx)(e.h2,{id:"the-navigation-problem",children:"The Navigation Problem"}),"\n",(0,s.jsx)(e.p,{children:"Your mobile robot stands in a warehouse filled with obstacles. It needs to reach a distant goal without crashing. How does it find a safe path?"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Path planning"})," is the algorithm that computes a collision-free path from start to goal. This week covers the fundamental algorithms that power robot navigation."]}),"\n",(0,s.jsx)(e.h2,{id:"part-1-configuration-space",children:"Part 1: Configuration Space"}),"\n",(0,s.jsxs)(e.p,{children:["Before we plan, we need to understand the ",(0,s.jsx)(e.strong,{children:"robot's configuration space"})," (C-space)\u2014the space of all possible robot poses."]}),"\n",(0,s.jsx)(e.h3,{id:"2d-mobile-robot-c-space",children:"2D Mobile Robot C-Space"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class ConfigurationSpace:\n    def __init__(self, world_map, robot_radius=0.25):\n        """Initialize C-space from occupancy grid"""\n        self.world_map = world_map  # 2D binary grid\n        self.robot_radius = robot_radius\n\n    def inflate_obstacles(self):\n        """Expand obstacles by robot radius for safety"""\n        # Dilate obstacles: any cell within robot_radius of obstacle\n        # becomes obstacle\n\n        inflated = np.zeros_like(self.world_map)\n\n        for y in range(self.world_map.shape[0]):\n            for x in range(self.world_map.shape[1]):\n                if self.world_map[y, x]:  # Is obstacle\n                    # Mark all cells within radius as inflated\n                    for dy in range(-int(self.robot_radius), int(self.robot_radius)+1):\n                        for dx in range(-int(self.robot_radius), int(self.robot_radius)+1):\n                            if dy**2 + dx**2 <= self.robot_radius**2:\n                                ny = y + dy\n                                nx = x + dx\n                                if 0 <= ny < inflated.shape[0] and 0 <= nx < inflated.shape[1]:\n                                    inflated[ny, nx] = 1\n\n        return inflated\n\n    def is_collision_free(self, x, y):\n        """Check if robot at (x, y) is collision-free"""\n        grid_x = int(x)\n        grid_y = int(y)\n\n        if 0 <= grid_x < self.world_map.shape[1] and \\\n           0 <= grid_y < self.world_map.shape[0]:\n            return not self.world_map[grid_y, grid_x]\n        return False\n'})}),"\n",(0,s.jsx)(e.h2,{id:"part-2-graph-based-planning",children:"Part 2: Graph-Based Planning"}),"\n",(0,s.jsx)(e.h3,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,s.jsx)(e.p,{children:"Find shortest path on a graph using greedy exploration."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class DijkstraPlanner:\n    def plan(self, start, goal, cspace):\n        """Plan path using Dijkstra\'s algorithm"""\n\n        import heapq\n\n        # Priority queue: (distance, node)\n        queue = [(0, tuple(start))]\n        distances = {tuple(start): 0}\n        parents = {}\n\n        while queue:\n            current_distance, current = heapq.heappop(queue)\n\n            # Skip if already processed\n            if current in parents:\n                continue\n\n            # Found goal\n            if current == tuple(goal):\n                return self.reconstruct_path(parents, goal)\n\n            # Explore neighbors\n            for neighbor in self.get_neighbors(current, cspace):\n                distance = current_distance + 1\n\n                if neighbor not in distances or distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    parents[neighbor] = current\n                    heapq.heappush(queue, (distance, neighbor))\n\n        return None  # No path found\n\n    def get_neighbors(self, cell, cspace, resolution=0.1):\n        """Get collision-free neighboring cells"""\n        x, y = cell\n        neighbors = []\n\n        for dx in [-resolution, 0, resolution]:\n            for dy in [-resolution, 0, resolution]:\n                if dx == 0 and dy == 0:\n                    continue\n\n                nx, ny = x + dx, y + dy\n\n                if cspace.is_collision_free(nx, ny):\n                    neighbors.append((nx, ny))\n\n        return neighbors\n\n    def reconstruct_path(self, parents, goal):\n        """Reconstruct path from parent pointers"""\n        path = []\n        current = tuple(goal)\n\n        while current in parents:\n            path.append(current)\n            current = parents[current]\n\n        path.append(current)\n        return list(reversed(path))\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Characteristics"}),": Optimal but slow. Explores all directions equally."]}),"\n",(0,s.jsx)(e.h3,{id:"a-algorithm",children:"A* Algorithm"}),"\n",(0,s.jsxs)(e.p,{children:["Like Dijkstra but uses ",(0,s.jsx)(e.strong,{children:"heuristics"})," to guide search toward goal."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class AStarPlanner:\n    def plan(self, start, goal, cspace):\n        """Plan path using A* algorithm"""\n\n        import heapq\n\n        def heuristic(a, b):\n            """Euclidean distance heuristic"""\n            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5\n\n        start_tuple = tuple(start)\n        goal_tuple = tuple(goal)\n\n        # Priority queue: (f_score, node)\n        # f_score = g_score (distance from start) + h_score (heuristic to goal)\n        queue = [(heuristic(start, goal), start_tuple)]\n        g_scores = {start_tuple: 0}\n        f_scores = {start_tuple: heuristic(start, goal)}\n        parents = {}\n\n        while queue:\n            _, current = heapq.heappop(queue)\n\n            if current == goal_tuple:\n                return self.reconstruct_path(parents, goal)\n\n            # Explore neighbors\n            for neighbor in self.get_neighbors(current, cspace):\n                tentative_g = g_scores[current] + 1\n\n                if neighbor not in g_scores or tentative_g < g_scores[neighbor]:\n                    parents[neighbor] = current\n                    g_scores[neighbor] = tentative_g\n                    f_score = tentative_g + heuristic(neighbor, goal)\n                    f_scores[neighbor] = f_score\n\n                    heapq.heappush(queue, (f_score, neighbor))\n\n        return None\n\n    def get_neighbors(self, cell, cspace, resolution=0.1):\n        """Get collision-free neighbors"""\n        x, y = cell\n        neighbors = []\n\n        for dx in [-resolution, 0, resolution]:\n            for dy in [-resolution, 0, resolution]:\n                if dx == 0 and dy == 0:\n                    continue\n\n                nx, ny = x + dx, y + dy\n\n                if cspace.is_collision_free(nx, ny):\n                    neighbors.append((nx, ny))\n\n        return neighbors\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Characteristics"}),": Faster than Dijkstra, optimal with admissible heuristic. Most commonly used."]}),"\n",(0,s.jsx)(e.h2,{id:"part-3-sampling-based-planning",children:"Part 3: Sampling-Based Planning"}),"\n",(0,s.jsxs)(e.p,{children:["For high-dimensional spaces (robotic arms with 7+ DOF), grid-based methods become impractical. ",(0,s.jsx)(e.strong,{children:"Sampling-based planners"})," work in high dimensions."]}),"\n",(0,s.jsx)(e.h3,{id:"rapidly-exploring-random-tree-rrt",children:"Rapidly-exploring Random Tree (RRT)"}),"\n",(0,s.jsx)(e.p,{children:"Incrementally build a tree by randomly sampling the C-space."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class RRTPlanner:\n    def __init__(self, cspace, step_size=0.5, max_iterations=5000):\n        """Initialize RRT planner"""\n        self.cspace = cspace\n        self.step_size = step_size\n        self.max_iterations = max_iterations\n\n    def plan(self, start, goal, goal_bias=0.1):\n        """Plan using RRT"""\n\n        class Node:\n            def __init__(self, config):\n                self.config = config\n                self.parent = None\n                self.children = []\n\n        root = Node(start)\n        goal_node = Node(goal)\n\n        for iteration in range(self.max_iterations):\n            # Random sample: 10% goal, 90% random\n            if np.random.random() < goal_bias:\n                random_config = goal\n            else:\n                random_config = self.random_sample()\n\n            # Find nearest node in tree\n            nearest = self.nearest_node(root, random_config)\n\n            # Try to extend toward random config\n            new_config = self.extend(nearest.config, random_config)\n\n            if new_config is not None:\n                new_node = Node(new_config)\n                new_node.parent = nearest\n                nearest.children.append(new_node)\n\n                # Check if reached goal\n                if self.distance(new_config, goal) < self.step_size:\n                    new_node.parent = nearest\n                    nearest.children.append(new_node)\n                    goal_node.parent = new_node\n                    return self.extract_path(goal_node)\n\n        return None\n\n    def random_sample(self):\n        """Sample random configuration in C-space"""\n        # For 2D: random (x, y) in bounds\n        x = np.random.uniform(0, 50)  # World bounds\n        y = np.random.uniform(0, 50)\n        return (x, y)\n\n    def nearest_node(self, root, config):\n        """Find node in tree nearest to config"""\n        min_distance = float(\'inf\')\n        nearest = None\n\n        # BFS/DFS through tree\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            distance = self.distance(node.config, config)\n\n            if distance < min_distance:\n                min_distance = distance\n                nearest = node\n\n            queue.extend(node.children)\n\n        return nearest\n\n    def extend(self, from_config, to_config):\n        """Extend from_config toward to_config by step_size"""\n        direction = np.array(to_config) - np.array(from_config)\n        norm = np.linalg.norm(direction)\n\n        if norm < 1e-6:\n            return None\n\n        direction = direction / norm\n\n        # Take step of size step_size\n        new_config = np.array(from_config) + direction * self.step_size\n\n        # Check collision\n        if self.cspace.is_collision_free(new_config[0], new_config[1]):\n            return tuple(new_config)\n\n        return None\n\n    def distance(self, config1, config2):\n        """Euclidean distance"""\n        return ((config1[0]-config2[0])**2 + (config1[1]-config2[1])**2)**0.5\n\n    def extract_path(self, goal_node):\n        """Extract path by following parent pointers"""\n        path = []\n        current = goal_node\n\n        while current is not None:\n            path.append(current.config)\n            current = current.parent\n\n        return list(reversed(path))\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Characteristics"}),": Works in high dimensions, fast, probabilistically complete (will find path if one exists)."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"RRT Growth:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Goal         \u2502\n\u2502     *           \u2502\n\u2502  \u2571  \u2502\u2572          \u2502\n\u2502 \u2571   \u2502 \u2572         \u2502\n\u2502\u2571    \u2502  \u2572        \u2502\n\u2502     \u2502   \u2572       \u2502\n\u2502     \u2502    \u2572      \u2502\n\u2502  Start    Tree  \u2502\n\u2502     *            \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(e.h2,{id:"part-4-real-world-planning",children:"Part 4: Real-World Planning"}),"\n",(0,s.jsx)(e.h3,{id:"handling-dynamic-obstacles",children:"Handling Dynamic Obstacles"}),"\n",(0,s.jsx)(e.p,{children:"Real environments change. A path valid at planning time might not be valid later."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class DynamicPathPlanner:\n    def __init__(self, cspace, replanning_frequency=10):\n        """Planner that replans when obstacles change"""\n        self.cspace = cspace\n        self.replanning_frequency = replanning_frequency\n        self.current_path = None\n        self.step_count = 0\n\n    def execute(self, robot_pose, goal, dynamic_obstacles):\n        """Execute path with replanning"""\n\n        # Every N steps, replan\n        if self.step_count % self.replanning_frequency == 0:\n            self.current_path = self.plan(robot_pose, goal)\n\n        # Follow current path\n        if self.current_path:\n            next_waypoint = self.current_path[0]\n\n            # Check if path is still valid\n            if not self.is_path_valid(self.current_path, dynamic_obstacles):\n                print("Path blocked! Replanning...")\n                self.current_path = self.plan(robot_pose, goal)\n\n            self.step_count += 1\n            return next_waypoint\n\n        return None\n\n    def is_path_valid(self, path, obstacles):\n        """Check if path collides with any obstacle"""\n        for pose in path:\n            for obstacle in obstacles:\n                distance = np.linalg.norm(\n                    np.array(pose) - np.array(obstacle[\'position\'])\n                )\n\n                if distance < obstacle[\'radius\']:\n                    return False\n\n        return True\n'})}),"\n",(0,s.jsx)(e.h2,{id:"week-7-learning-outcomes",children:"Week 7 Learning Outcomes"}),"\n",(0,s.jsx)(e.p,{children:"By the end of this week, you should be able to:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Explain"})," configuration spaces and obstacle inflation"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Implement"})," Dijkstra's algorithm for grid-based planning"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Apply"})," A* with heuristics for faster planning"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use"})," RRT for high-dimensional path planning"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Compare"})," graph-based vs. sampling-based methods"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Handle"})," dynamic obstacles with replanning"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"key-terminology",children:"Key Terminology"}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{children:"Term"}),(0,s.jsx)(e.th,{children:"Definition"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Configuration space (C-space)"})}),(0,s.jsx)(e.td,{children:"Space of all possible robot configurations"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Collision-free"})}),(0,s.jsx)(e.td,{children:"Configuration with no overlap with obstacles"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Heuristic"})}),(0,s.jsx)(e.td,{children:"Estimate of distance to goal (A* uses this)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Admissible heuristic"})}),(0,s.jsx)(e.td,{children:"Never overestimates distance to goal"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Dijkstra's algorithm"})}),(0,s.jsx)(e.td,{children:"Optimal path finding, explores equally in all directions"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsxs)(e.td,{children:[(0,s.jsxs)(e.em,{children:[(0,s.jsx)(e.em,{children:"A"})," algorithm"]}),"*"]}),(0,s.jsx)(e.td,{children:"Optimal path finding using heuristics (faster)"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"RRT"})}),(0,s.jsx)(e.td,{children:"Rapidly-exploring Random Tree for high-dimensional planning"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{children:(0,s.jsx)(e.strong,{children:"Probabilistically complete"})}),(0,s.jsx)(e.td,{children:"Will find path if one exists (given infinite time)"})]})]})]}),"\n",(0,s.jsx)(e.h2,{id:"discussion-questions",children:"Discussion Questions"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Heuristics"}),": Why does A* use Euclidean distance as a heuristic? What happens if heuristic overestimates?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Dimensions"}),": Dijkstra works on 2D grids. Can you use it for a 7-DOF robot arm? Why or why not?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Optimality"}),": RRT finds ",(0,s.jsx)(e.em,{children:"a"})," path but not necessarily optimal. How would you modify it to find better paths?"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Real-time"}),": Robot must plan at 10 Hz (100ms per decision). Which algorithm is suitable?"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"hands-on-activity",children:"Hands-On Activity"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.em,{children:[(0,s.jsx)(e.em,{children:"Implement A"})," path planner"]}),"*"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Create 20\xd720 grid with obstacles"}),"\n",(0,s.jsx)(e.li,{children:"Implement A* with Euclidean heuristic"}),"\n",(0,s.jsx)(e.li,{children:"Visualize: grid, start, goal, obstacles, planned path"}),"\n",(0,s.jsx)(e.li,{children:"Measure: path length and number of nodes explored"}),"\n",(0,s.jsx)(e.li,{children:"Compare A* vs. Dijkstra (how many more nodes did Dijkstra explore?)"}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"resources-for-deeper-learning",children:"Resources for Deeper Learning"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Book"}),': "Computational Geometry" - de Berg, Cheong, van Kreveld, Overmars']}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Course"}),': "Robot Motion Planning" - UC Davis (YouTube)']}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Paper"}),': "RRT-Connect: An Efficient Approach to Single-Query Path Planning" - Kuffner & LaValle']}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Tool"}),": OMPL (Open Motion Planning Library) - free software"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Visualization"}),': "Path Planning Visualizer" - interactive web tool']}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Next"}),": Week 8 - Trajectory Planning & Collision Avoidance"]}),"\n",(0,s.jsxs)(e.p,{children:["\ud83d\udca1 ",(0,s.jsx)(e.strong,{children:"Tip"}),": A* explores fewer nodes than Dijkstra. Visualize which cells each algorithm visits!"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:function(n,e,i){i.d(e,{R:function(){return o},x:function(){return a}});var r=i(6540);const s={},t=r.createContext(s);function o(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);